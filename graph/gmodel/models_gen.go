// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gmodel

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

type Address struct {
	ID                     int64          `json:"id" sql:"primary_key"`
	CreatedAt              time.Time      `json:"createdAt"`
	UpdatedAt              time.Time      `json:"updatedAt"`
	Latitude               float64        `json:"latitude"`
	Longitude              float64        `json:"longitude"`
	Distance               *float64       `json:"distance,omitempty" alias:"address.distance"`
	MapsLink               string         `json:"mapsLink"`
	FullAddress            string         `json:"fullAddress"`
	Street                 *string        `json:"street,omitempty"`
	City                   string         `json:"city"`
	AdministrativeDivision string         `json:"administrativeDivision"`
	ZipCode                string         `json:"zipCode"`
	CountryCode            string         `json:"countryCode"`
	Country                *string        `json:"country,omitempty" alias:"country.name"`
	CreatedByID            *int64         `json:"createdById,omitempty"`
	CreatedBy              *CreatedByUser `json:"createdBy,omitempty"`
	UpdatedByID            *int64         `json:"updatedById,omitempty"`
	UpdatedBy              *UpdatedByUser `json:"updatedBy,omitempty"`
}

type AdministrativeDivision struct {
	Name   string `json:"name" alias:"administrative_division.administrative_division"`
	Cities string `json:"cities"`
}

type Auth struct {
	Token     string `json:"token"`
	User      *User  `json:"user"`
	IsNewUser *bool  `json:"isNewUser,omitempty"`
}

type Branch struct {
	ID          int64          `json:"id" sql:"primary_key"`
	Name        string         `json:"name"`
	AddressID   int64          `json:"addressId"`
	Address     *Address       `json:"address"`
	StoreID     int64          `json:"storeId"`
	Store       *Store         `json:"store,omitempty"`
	Products    []*Product     `json:"products,omitempty"`
	CreatedByID *int64         `json:"createdById,omitempty"`
	CreatedBy   *CreatedByUser `json:"createdBy,omitempty"`
	UpdatedByID *int64         `json:"updatedById,omitempty"`
	UpdatedBy   *UpdatedByUser `json:"updatedBy,omitempty"`
}

type BranchList struct {
	ID        int64     `json:"id" sql:"primary_key"`
	UserID    int64     `json:"userId"`
	ListID    int64     `json:"listId"`
	List      *List     `json:"list,omitempty"`
	BranchID  int64     `json:"branchId"`
	Branch    *Branch   `json:"branch,omitempty"`
	CreatedAt time.Time `json:"createdAt"`
}

type BranchListWithPrices struct {
	ID               int64     `json:"id" sql:"primary_key"`
	BranchID         int64     `json:"branchId"`
	Branch           *Branch   `json:"branch,omitempty"`
	Stock            *Stock    `json:"stock,omitempty"`
	ApproximatePrice *float64  `json:"approximatePrice,omitempty"`
	CreatedAt        time.Time `json:"createdAt"`
}

type Brand struct {
	Brand    string `json:"brand" alias:"product.brand"`
	Products int64  `json:"products"`
}

type Category struct {
	ID               int64   `json:"id" sql:"primary_key"`
	Name             string  `json:"name"`
	Path             string  `json:"path"`
	ExpandedPathname string  `json:"expandedPathname"`
	CategoryAlias    *string `json:"categoryAlias,omitempty"`
	Depth            *int    `json:"depth,omitempty"`
}

type Country struct {
	Code                    string                    `json:"code" sql:"primary_key"`
	Name                    string                    `json:"name"`
	AdministrativeDivisions []*AdministrativeDivision `json:"administrativeDivisions"`
	Currency                *Currency                 `json:"currency,omitempty"`
	CallingCode             *string                   `json:"callingCode,omitempty"`
	Language                *string                   `json:"language,omitempty"`
}

type CreateAccountInput struct {
	Email       string  `json:"email" validate:"required,email"`
	PhoneNumber *string `json:"phoneNumber,omitempty" validate:"omitempty,e164"`
	Name        string  `json:"name" validate:"required"`
	Password    string  `json:"password" validate:"required"`
}

type CreateAddress struct {
	Latitude               float64 `json:"latitude" validate:"required,latitude"`
	Longitude              float64 `json:"longitude" validate:"required,longitude"`
	MapsLink               string  `json:"mapsLink" validate:"required,http_url"`
	FullAddress            string  `json:"fullAddress" validate:"required,contains"`
	Street                 *string `json:"street,omitempty"`
	City                   string  `json:"city" validate:"required"`
	AdministrativeDivision string  `json:"administrativeDivision" validate:"required"`
	CountryCode            string  `json:"countryCode" validate:"required,iso3166_1_alpha2"`
	ZipCode                int     `json:"zipCode" validate:"required"`
}

type CreateBranch struct {
	Name    string         `json:"name" validate:"required"`
	Address *CreateAddress `json:"address"`
	StoreID int64          `json:"storeId" validate:"required"`
}

type CreateCategory struct {
	Name       string `json:"name"`
	ParentPath []int  `json:"parentPath"`
}

type CreateGroceryListInput struct {
	Name string `json:"name"`
}

type CreateGroceryListItemInput struct {
	ProductID *int64  `json:"productId,omitempty"`
	Quantity  *int    `json:"quantity,omitempty"`
	Unit      *string `json:"unit,omitempty"`
	Category  *string `json:"category,omitempty"`
	Weight    *string `json:"weight,omitempty"`
	Completed *bool   `json:"completed,omitempty"`
}

type CreatePrice struct {
	ProductID     int64           `json:"productId"`
	BranchID      int64           `json:"branchId"`
	Amount        float64         `json:"amount" validate:"gt=0"`
	CurrencyCode  *string         `json:"currencyCode,omitempty"`
	Sale          bool            `json:"sale"`
	OriginalPrice *float64        `json:"originalPrice,omitempty"`
	Condition     *string         `json:"condition,omitempty"`
	UnitType      string          `json:"unitType"`
	ImageID       *string         `json:"imageId,omitempty"`
	ExpiresAt     *time.Time      `json:"expiresAt,omitempty"`
	ImageFile     *graphql.Upload `json:"imageFile,omitempty"`
}

type CreateProduct struct {
	Name                 string          `json:"name" validate:"required"`
	Description          string          `json:"description"`
	URL                  *string         `json:"url,omitempty" validate:"omitempty,http_url"`
	Brand                string          `json:"brand"`
	Code                 string          `json:"code" validate:"required"`
	Color                *string         `json:"color,omitempty"`
	Model                *string         `json:"model,omitempty"`
	CategoryID           int64           `json:"categoryId" validate:"required"`
	Weight               *string         `json:"weight,omitempty"`
	QuantityValue        *int            `json:"quantityValue,omitempty"`
	QuantityType         *string         `json:"quantityType,omitempty"`
	LowestRecordedPrice  *float64        `json:"lowestRecordedPrice,omitempty"`
	HighestRecordedPrice *float64        `json:"highestRecordedPrice,omitempty"`
	ImageFile            *graphql.Upload `json:"imageFile,omitempty"`
	ImageBase64          *string         `json:"imageBase64,omitempty"`
	ImageURL             *string         `json:"imageUrl,omitempty" validate:"omitempty,http_url"`
}

type CreateStock struct {
	ProductID int64 `json:"productId"`
	StoreID   int64 `json:"storeId"`
	BranchID  int64 `json:"branchId"`
}

type CreateStore struct {
	Name       string          `json:"name"`
	LogoBase64 *string         `json:"logoBase64,omitempty"`
	Website    string          `json:"website" validate:"http_url"`
	LogoFile   *graphql.Upload `json:"logoFile,omitempty"`
}

type CreatedByUser struct {
	ID     int64   `json:"id" sql:"primary_key" alias:"created_by_user.id"`
	Name   string  `json:"name" alias:"created_by_user.name"`
	Avatar *string `json:"avatar,omitempty" alias:"created_by_user.avatar"`
	Active *bool   `json:"active,omitempty" alias:"created_by_user.active"`
}

type Currency struct {
	CurrencyCode string `json:"currencyCode" sql:"primary_key"`
	Name         string `json:"name"`
	Symbol       string `json:"symbol"`
	SymbolNative string `json:"symbolNative"`
	Decimals     int    `json:"decimals"`
	NumToBasic   *int   `json:"numToBasic,omitempty"`
}

type GroceryList struct {
	ID               int64              `json:"id" sql:"primary_key"`
	UserID           int64              `json:"userId"`
	Default          bool               `json:"default"`
	Name             string             `json:"name"`
	GroceryListItems []*GroceryListItem `json:"groceryListItems,omitempty"`
	CreatedAt        time.Time          `json:"createdAt"`
	UpdatedAt        time.Time          `json:"updatedAt"`
}

type GroceryListItem struct {
	ID            int64        `json:"id" sql:"primary_key"`
	GroceryListID int64        `json:"groceryListId"`
	GroceryList   *GroceryList `json:"groceryList,omitempty"`
	ProductID     *int64       `json:"productId,omitempty"`
	Product       *Product     `json:"product,omitempty"`
	Quantity      int          `json:"quantity"`
	Unit          *string      `json:"unit,omitempty"`
	Category      *string      `json:"category,omitempty"`
	Weight        *string      `json:"weight,omitempty"`
	Completed     bool         `json:"completed"`
	CreatedAt     time.Time    `json:"createdAt"`
	UpdatedAt     time.Time    `json:"updatedAt"`
}

type List struct {
	ID          int64          `json:"id" sql:"primary_key"`
	Name        string         `json:"name"`
	Type        ListType       `json:"type"`
	UserID      int64          `json:"userId"`
	ProductList []*ProductList `json:"productList,omitempty"`
	BranchList  []*BranchList  `json:"branchList,omitempty"`
	CreatedAt   time.Time      `json:"createdAt"`
}

type LocationInput struct {
	Latitude     float64 `json:"latitude" validate:"required,latitude"`
	Longitude    float64 `json:"longitude" validate:"required,longitude"`
	RadiusMeters *int    `json:"radiusMeters,omitempty"`
}

type Mutation struct {
}

type PaginatedBranches struct {
	Branches  []*Branch  `json:"branches"`
	Paginator *Paginator `json:"paginator"`
}

type PaginatedPriceHistory struct {
	Prices    []*Price   `json:"prices"`
	Paginator *Paginator `json:"paginator"`
}

type PaginatedProductBilling struct {
	Data      []*ProductBilling `json:"data"`
	Paginator *Paginator        `json:"paginator"`
}

type PaginatedProducts struct {
	Products  []*Product `json:"products"`
	Paginator *Paginator `json:"paginator"`
}

type PaginatedSearch struct {
	Searches  []*SearchHistory `json:"searches"`
	Paginator *Paginator       `json:"paginator"`
}

type PaginatedStocks struct {
	Stocks    []*Stock   `json:"stocks"`
	Paginator *Paginator `json:"paginator"`
}

type PaginatedUsers struct {
	Users     []*User    `json:"users"`
	Paginator *Paginator `json:"paginator"`
}

type Paginator struct {
	Next     *int `json:"next,omitempty"`
	Page     int  `json:"page"`
	Prev     *int `json:"prev,omitempty"`
	Total    int  `json:"total"`
	Limit    int  `json:"limit"`
	NumPages int  `json:"numPages"`
}

type PaginatorInput struct {
	Limit int `json:"limit" validate:"required,gt=0,lt=200"`
	Page  int `json:"page" validate:"required,gt=0"`
}

type Price struct {
	ID            int64          `json:"id" sql:"primary_key"`
	Amount        float64        `json:"amount"`
	CurrencyCode  string         `json:"currencyCode"`
	ProductID     int64          `json:"productId"`
	Product       *Product       `json:"product,omitempty"`
	StockID       int64          `json:"stockId"`
	Stock         *Stock         `json:"stock,omitempty"`
	StoreID       int64          `json:"storeId"`
	Store         *Store         `json:"store,omitempty"`
	BranchID      int64          `json:"branchId"`
	Branch        *Branch        `json:"branch,omitempty"`
	Sale          bool           `json:"sale"`
	OriginalPrice *float64       `json:"originalPrice,omitempty"`
	Condition     *string        `json:"condition,omitempty"`
	UnitType      string         `json:"unitType"`
	ImageID       *string        `json:"imageId,omitempty"`
	ExpiresAt     *time.Time     `json:"expiresAt,omitempty"`
	CreatedAt     time.Time      `json:"createdAt"`
	UpdatedAt     time.Time      `json:"updatedAt"`
	CreatedByID   *int64         `json:"createdById,omitempty"`
	CreatedBy     *CreatedByUser `json:"createdBy,omitempty"`
	UpdatedByID   *int64         `json:"updatedById,omitempty"`
	UpdatedBy     *UpdatedByUser `json:"updatedBy,omitempty"`
}

type PriceHistoryFilter struct {
	OrderBy *OrderByType `json:"orderBy,omitempty"`
}

type Product struct {
	ID                   int64          `json:"id" sql:"primary_key"`
	Name                 string         `json:"name"`
	Image                string         `json:"image"`
	Description          string         `json:"description"`
	URL                  *string        `json:"url,omitempty"`
	Brand                string         `json:"brand"`
	Code                 string         `json:"code"`
	Color                *string        `json:"color,omitempty"`
	Model                *string        `json:"model,omitempty"`
	CategoryID           int64          `json:"categoryId"`
	Category             *Category      `json:"category,omitempty"`
	Stock                *Stock         `json:"stock,omitempty"`
	WeightValue          *float64       `json:"weightValue,omitempty"`
	WeightType           *string        `json:"weightType,omitempty"`
	QuantityValue        int            `json:"quantityValue"`
	QuantityType         string         `json:"quantityType"`
	LowestRecordedPrice  *float64       `json:"lowestRecordedPrice,omitempty"`
	HighestRecordedPrice *float64       `json:"highestRecordedPrice,omitempty"`
	CreatedAt            time.Time      `json:"createdAt"`
	UpdatedAt            time.Time      `json:"updatedAt"`
	CreatedByID          *int64         `json:"createdById,omitempty"`
	CreatedBy            *CreatedByUser `json:"createdBy,omitempty"`
	UpdatedByID          *int64         `json:"updatedById,omitempty"`
	UpdatedBy            *UpdatedByUser `json:"updatedBy,omitempty"`
	ProductList          []*ProductList `json:"productList"`
	Views                int            `json:"views"`
}

type ProductBilling struct {
	ID              int64        `json:"id" sql:"primary_key"`
	ProductID       int64        `json:"productId"`
	Product         *Product     `json:"product,omitempty"`
	UserID          int64        `json:"userId"`
	User            *UserShallow `json:"user,omitempty"`
	CreatedAt       time.Time    `json:"createdAt"`
	Rate            float64      `json:"rate"`
	BillingRateType string       `json:"billingRateType"`
	PaidAt          *time.Time   `json:"paidAt,omitempty"`
}

type ProductExtractionFields struct {
	Brand       string  `json:"brand"`
	ProductName string  `json:"productName"`
	Weight      *string `json:"weight,omitempty"`
	Quantity    *int    `json:"quantity,omitempty"`
	Category    string  `json:"category"`
}

type ProductExtractionResponse struct {
	Brand      string    `json:"brand"`
	Name       string    `json:"name"`
	Weight     *string   `json:"weight,omitempty"`
	Quantity   *int      `json:"quantity,omitempty"`
	CategoryID *int64    `json:"categoryId,omitempty"`
	Category   *Category `json:"category,omitempty"`
}

type ProductList struct {
	ID        int64     `json:"id" sql:"primary_key"`
	UserID    int64     `json:"userId"`
	ListID    int64     `json:"listId"`
	List      *List     `json:"list,omitempty"`
	Type      *ListType `json:"type,omitempty" alias:"list_type"`
	ProductID int64     `json:"productId"`
	Product   *Product  `json:"product,omitempty"`
	Stock     *Stock    `json:"stock,omitempty"`
	StockID   *int64    `json:"stockId,omitempty"`
	CreatedAt time.Time `json:"createdAt"`
}

type ProductNutriment struct {
	Salt                    *float64 `json:"salt"`
	Salt100g                *float64 `json:"salt_100g"`
	SaltValue               *float64 `json:"salt_value"`
	SaltServing             *float64 `json:"salt_serving"`
	SaltUnit                *string  `json:"salt_unit"`
	Sugars100g              *float64 `json:"sugars_100g"`
	Sugars                  *float64 `json:"sugars"`
	SugarsUnit              *string  `json:"sugars_unit"`
	SugarsServing           *float64 `json:"sugars_serving"`
	SugarsValue             *float64 `json:"sugars_value"`
	Iron                    *float64 `json:"iron"`
	IronValue               *float64 `json:"iron_value"`
	IronLabel               *string  `json:"iron_label"`
	IronUnit                *string  `json:"iron_unit"`
	Iron100g                *float64 `json:"iron_100g"`
	IronServing             *float64 `json:"iron_serving"`
	CalciumUnit             *string  `json:"calcium_unit"`
	CalciumServing          *float64 `json:"calcium_serving"`
	Calcium                 *float64 `json:"calcium"`
	CalciumValue            *float64 `json:"calcium_value"`
	CalciumLabel            *string  `json:"calcium_label"`
	Calcium100g             *float64 `json:"calcium_100g"`
	Cholesterol100g         *float64 `json:"cholesterol_100g"`
	SaturatedFat100g        *float64 `json:"saturated-fat_100g"`
	SaturatedFatServing     *float64 `json:"saturated-fat_serving"`
	SaturatedFat            *float64 `json:"saturated-fat"`
	SaturatedFatValue       *float64 `json:"saturated-fat_value"`
	SaturatedFatUnit        *string  `json:"saturated-fat_unit"`
	Fat100g                 *float64 `json:"fat_100g"`
	FatServing              *float64 `json:"fat_serving"`
	FatValue                *float64 `json:"fat_value"`
	FatUnit                 *string  `json:"fat_unit"`
	Fat                     *float64 `json:"fat"`
	TransFatLabel           *string  `json:"trans-fat_label"`
	TransFatUnit            *string  `json:"trans-fat_unit"`
	TransFat                *float64 `json:"trans-fat"`
	TransFat100g            *float64 `json:"trans-fat_100g"`
	TransFatServing         *float64 `json:"trans-fat_serving"`
	TransFatValue           *float64 `json:"trans-fat_value"`
	VitaminA                *float64 `json:"vitamin-a"`
	VitaminA100g            *float64 `json:"vitamin-a_100g"`
	VitaminAValue           *float64 `json:"vitamin-a_value"`
	VitaminAServing         *float64 `json:"vitamin-a_serving"`
	VitaminAUnit            *string  `json:"vitamin-a_unit"`
	VitaminALabel           *string  `json:"vitamin-a_label"`
	VitaminCValue           *float64 `json:"vitamin-c_value"`
	VitaminCUnit            *string  `json:"vitamin-c_unit"`
	VitaminC100g            *float64 `json:"vitamin-c_100g"`
	VitaminC                *float64 `json:"vitamin-c"`
	VitaminCServing         *float64 `json:"vitamin-c_serving"`
	VitaminCLabel           *string  `json:"vitamin-c_label"`
	Proteins100g            *float64 `json:"proteins_100g"`
	ProteinsServing         *float64 `json:"proteins_serving"`
	ProteinsValue           *float64 `json:"proteins_value"`
	ProteinsUnit            *string  `json:"proteins_unit"`
	Proteins                *float64 `json:"proteins"`
	PolyunsaturatedFat100g  *float64 `json:"polyunsaturated-fat_100g"`
	Potassium100g           *float64 `json:"potassium_100g"`
	Sodium                  *float64 `json:"sodium"`
	SodiumServing           *float64 `json:"sodium_serving"`
	SodiumValue             *float64 `json:"sodium_value"`
	Sodium100g              *float64 `json:"sodium_100g"`
	SodiumUnit              *string  `json:"sodium_unit"`
	CarbohydratesUnit       *string  `json:"carbohydrates_unit"`
	CarbohydratesValue      *float64 `json:"carbohydrates_value"`
	Carbohydrates100g       *float64 `json:"carbohydrates_100g"`
	Carbohydrates           *float64 `json:"carbohydrates"`
	CarbohydratesServing    *float64 `json:"carbohydrates_serving"`
	AlcoholValue            *float64 `json:"alcohol_value"`
	AlcoholServing          *float64 `json:"alcohol_serving"`
	AlcoholUnit             *string  `json:"alcohol_unit"`
	Alcohol100g             *float64 `json:"alcohol_100g"`
	Alcohol                 *float64 `json:"alcohol"`
	MonounsaturatedFat100g  *float64 `json:"monounsaturated-fat_100g"`
	NovaGroup               *float64 `json:"nova-group"`
	NovaGroupServing        *float64 `json:"nova-group_serving"`
	NovaGroup100g           *float64 `json:"nova-group_100g"`
	Energy                  *float64 `json:"energy"`
	EnergyServing           *float64 `json:"energy_serving"`
	EnergyKcalServing       *float64 `json:"energy-kcal_serving"`
	EnergyKcal              *float64 `json:"energy-kcal"`
	Energy100g              *float64 `json:"energy_100g"`
	EnergyUnit              *string  `json:"energy_unit"`
	EnergyKcalValue         *float64 `json:"energy-kcal_value"`
	EnergyKcalUnit          *string  `json:"energy-kcal_unit"`
	EnergyKcal100g          *float64 `json:"energy-kcal_100g"`
	EnergyValue             *float64 `json:"energy_value"`
	NutritionScoreUk100g    *float64 `json:"nutrition-score-uk_100g"`
	NutritionScoreFrServing *float64 `json:"nutrition-score-fr_serving"`
	NutritionScoreFr        *float64 `json:"nutrition-score-fr"`
	NutritionScoreFr100g    *float64 `json:"nutrition-score-fr_100g"`
	NutritionScoreUkServing *float64 `json:"nutrition-score-uk_serving"`
	NutritionScoreUk        *float64 `json:"nutrition-score-uk"`
	Fiber                   *float64 `json:"fiber"`
	Fiber100g               *float64 `json:"fiber_100g"`
	FiberValue              *float64 `json:"fiber_value"`
	FiberServing            *float64 `json:"fiber_serving"`
	FiberUnit               *string  `json:"fiber_unit"`
}

type ProductNutrition struct {
	ProductID              int64             `json:"productId" sql:"primary_key"`
	IngredientText         *string           `json:"ingredientText,omitempty"`
	IngredientList         []string          `json:"ingredientList,omitempty"`
	Nutriments             *ProductNutriment `json:"nutriments,omitempty"`
	ServingSize            *string           `json:"servingSize,omitempty"`
	ServingSizeValue       *float64          `json:"servingSizeValue,omitempty"`
	ServingSizeUnit        *string           `json:"servingSizeUnit,omitempty"`
	OpenfoodfactsUpdatedAt string            `json:"openfoodfactsUpdatedAt"`
	Vegan                  *bool             `json:"vegan,omitempty"`
	Vegetarian             *bool             `json:"vegetarian,omitempty"`
	GlutenFree             *bool             `json:"glutenFree,omitempty"`
	LactoseFree            *bool             `json:"lactoseFree,omitempty"`
	Halal                  *bool             `json:"halal,omitempty"`
	Kosher                 *bool             `json:"kosher,omitempty"`
	CreatedAt              time.Time         `json:"createdAt"`
	UpdatedAt              time.Time         `json:"updatedAt"`
}

type ProductSearch struct {
	Query       *string        `json:"query,omitempty"`
	Category    *string        `json:"category,omitempty"`
	CategoryID  *int64         `json:"categoryId,omitempty"`
	BranchID    *int64         `json:"branchId,omitempty"`
	Location    *LocationInput `json:"location,omitempty"`
	StoreID     *int64         `json:"storeId,omitempty"`
	Sale        *bool          `json:"sale,omitempty"`
	SortByPrice *string        `json:"sortByPrice,omitempty"`
	WideSearch  *bool          `json:"wideSearch,omitempty"`
	Weight      *string        `json:"weight,omitempty"`
	Quantity    *int           `json:"quantity,omitempty"`
	Brand       *string        `json:"brand,omitempty"`
}

type Query struct {
}

type SaveExternalProductInput struct {
	NumPagesToQuery int     `json:"numPagesToQuery"`
	Search          string  `json:"search"`
	Category        *string `json:"category,omitempty"`
	Brand           *string `json:"brand,omitempty"`
	Upc             *string `json:"upc,omitempty"`
	Offset          *int    `json:"offset,omitempty"`
}

type SearchHistory struct {
	ID         int64     `json:"id"`
	SearchTerm string    `json:"searchTerm"`
	CreatedAt  time.Time `json:"createdAt"`
}

type SearchResult struct {
	Total  int `json:"total"`
	Added  int `json:"added"`
	Failed int `json:"failed"`
}

type Stock struct {
	ID            int64          `json:"id" sql:"primary_key"`
	ProductID     int64          `json:"productId"`
	Product       *Product       `json:"product,omitempty"`
	StoreID       int64          `json:"storeId"`
	Store         *Store         `json:"store,omitempty"`
	BranchID      int64          `json:"branchId"`
	Branch        *Branch        `json:"branch,omitempty"`
	LatestPriceID int64          `json:"latestPriceId"`
	LatestPrice   *Price         `json:"latestPrice,omitempty"`
	CreatedAt     time.Time      `json:"createdAt"`
	UpdatedAt     time.Time      `json:"updatedAt"`
	CreatedByID   *int64         `json:"createdById,omitempty"`
	CreatedBy     *CreatedByUser `json:"createdBy,omitempty"`
	UpdatedByID   *int64         `json:"updatedById,omitempty"`
	UpdatedBy     *UpdatedByUser `json:"updatedBy,omitempty"`
}

type Store struct {
	ID          int64          `json:"id" sql:"primary_key"`
	Name        string         `json:"name"`
	Logo        string         `json:"logo"`
	Website     string         `json:"website"`
	CreatedByID *int64         `json:"createdById,omitempty"`
	CreatedBy   *CreatedByUser `json:"createdBy,omitempty"`
	UpdatedByID *int64         `json:"updatedById,omitempty"`
	UpdatedBy   *UpdatedByUser `json:"updatedBy,omitempty"`
}

type UpdateProduct struct {
	Name                 *string         `json:"name,omitempty"`
	Description          *string         `json:"description,omitempty"`
	URL                  *string         `json:"url,omitempty" validate:"omitempty,http_url"`
	Brand                *string         `json:"brand,omitempty"`
	Code                 *string         `json:"code,omitempty"`
	Color                *string         `json:"color,omitempty"`
	Model                *string         `json:"model,omitempty"`
	CategoryID           *int64          `json:"categoryId,omitempty"`
	Weight               *string         `json:"weight,omitempty"`
	QuantityValue        *int            `json:"quantityValue,omitempty"`
	QuantityType         *string         `json:"quantityType,omitempty"`
	LowestRecordedPrice  *float64        `json:"lowestRecordedPrice,omitempty"`
	HighestRecordedPrice *float64        `json:"highestRecordedPrice,omitempty"`
	ImageFile            *graphql.Upload `json:"imageFile,omitempty"`
	ImageBase64          *string         `json:"imageBase64,omitempty"`
}

type UpdateUser struct {
	Name         *string         `json:"name,omitempty"`
	AvatarFile   *graphql.Upload `json:"avatarFile,omitempty"`
	AvatarBase64 *string         `json:"avatarBase64,omitempty"`
	BirthDate    *time.Time      `json:"birthDate,omitempty"`
	Bio          *string         `json:"bio,omitempty"`
	Address      *string         `json:"address,omitempty"`
}

type UpdateUserFull struct {
	Email        *string         `json:"email,omitempty" validate:"omitempty,email"`
	PhoneNumber  *string         `json:"phoneNumber,omitempty" validate:"omitempty,e164"`
	Name         *string         `json:"name,omitempty"`
	AvatarFile   *graphql.Upload `json:"avatarFile,omitempty"`
	AvatarBase64 *string         `json:"avatarBase64,omitempty"`
	BirthDate    *time.Time      `json:"birthDate,omitempty"`
	Bio          *string         `json:"bio,omitempty"`
	Active       *bool           `json:"active,omitempty"`
	Role         *UserRole       `json:"role,omitempty"`
	Address      *string         `json:"address,omitempty"`
}

type UpdatedByUser struct {
	ID     int64   `json:"id" sql:"primary_key" alias:"updated_by_user.id"`
	Name   string  `json:"name" alias:"updated_by_user.name"`
	Avatar *string `json:"avatar,omitempty" alias:"updated_by_user.avatar"`
	Active *bool   `json:"active,omitempty" alias:"updated_by_user.active"`
}

type User struct {
	ID            int64             `json:"id" sql:"primary_key"`
	CreatedAt     time.Time         `json:"createdAt"`
	UpdatedAt     time.Time         `json:"updatedAt"`
	Email         string            `json:"email"`
	PhoneNumber   *string           `json:"phoneNumber,omitempty"`
	Name          string            `json:"name"`
	Avatar        *string           `json:"avatar,omitempty"`
	BirthDate     *time.Time        `json:"birthDate,omitempty"`
	Bio           *string           `json:"bio,omitempty"`
	Active        bool              `json:"active"`
	AuthPlatform  *AuthPlatformType `json:"authPlatform,omitempty" alias:"auth_state.platform"`
	AuthDevice    *AuthDeviceType   `json:"authDevice,omitempty" alias:"auth_state.device_type"`
	AuthStateID   *string           `json:"authStateId,omitempty" alias:"auth_state.id"`
	ExpoPushToken *string           `json:"expoPushToken,omitempty" alias:"auth_state.expo_push_token"`
	Role          UserRole          `json:"role"`
	AddressID     *int64            `json:"addressId,omitempty"`
	Address       *Address          `json:"address,omitempty"`
}

type UserFilter struct {
	Name  *string   `json:"name,omitempty"`
	Email *string   `json:"email,omitempty"`
	ID    *int64    `json:"id,omitempty"`
	Role  *UserRole `json:"role,omitempty"`
}

type UserShallow struct {
	ID     int64   `json:"id" sql:"primary_key" alias:"user.id"`
	Name   string  `json:"name" alias:"user.name"`
	Avatar *string `json:"avatar,omitempty" alias:"user.avatar"`
	Active *bool   `json:"active,omitempty" alias:"user.active"`
}

type ViewerTrailInput struct {
	StockID *int64  `json:"stockId,omitempty"`
	Origin  *string `json:"origin,omitempty"`
}

type AuthDeviceType string

const (
	AuthDeviceTypeIos     AuthDeviceType = "ios"
	AuthDeviceTypeAndroid AuthDeviceType = "android"
	AuthDeviceTypeWeb     AuthDeviceType = "web"
	AuthDeviceTypeOther   AuthDeviceType = "other"
	AuthDeviceTypeUnknown AuthDeviceType = "unknown"
)

var AllAuthDeviceType = []AuthDeviceType{
	AuthDeviceTypeIos,
	AuthDeviceTypeAndroid,
	AuthDeviceTypeWeb,
	AuthDeviceTypeOther,
	AuthDeviceTypeUnknown,
}

func (e AuthDeviceType) IsValid() bool {
	switch e {
	case AuthDeviceTypeIos, AuthDeviceTypeAndroid, AuthDeviceTypeWeb, AuthDeviceTypeOther, AuthDeviceTypeUnknown:
		return true
	}
	return false
}

func (e AuthDeviceType) String() string {
	return string(e)
}

func (e *AuthDeviceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthDeviceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthDeviceType", str)
	}
	return nil
}

func (e AuthDeviceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuthPlatformType string

const (
	AuthPlatformTypeInternal AuthPlatformType = "INTERNAL"
	AuthPlatformTypeApple    AuthPlatformType = "APPLE"
	AuthPlatformTypeGoogle   AuthPlatformType = "GOOGLE"
)

var AllAuthPlatformType = []AuthPlatformType{
	AuthPlatformTypeInternal,
	AuthPlatformTypeApple,
	AuthPlatformTypeGoogle,
}

func (e AuthPlatformType) IsValid() bool {
	switch e {
	case AuthPlatformTypeInternal, AuthPlatformTypeApple, AuthPlatformTypeGoogle:
		return true
	}
	return false
}

func (e AuthPlatformType) String() string {
	return string(e)
}

func (e *AuthPlatformType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthPlatformType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthPlatformType", str)
	}
	return nil
}

func (e AuthPlatformType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ListType string

const (
	ListTypeFavorites ListType = "FAVORITES"
	ListTypeWatchList ListType = "WATCH_LIST"
	ListTypePersonal  ListType = "PERSONAL"
)

var AllListType = []ListType{
	ListTypeFavorites,
	ListTypeWatchList,
	ListTypePersonal,
}

func (e ListType) IsValid() bool {
	switch e {
	case ListTypeFavorites, ListTypeWatchList, ListTypePersonal:
		return true
	}
	return false
}

func (e ListType) String() string {
	return string(e)
}

func (e *ListType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ListType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ListType", str)
	}
	return nil
}

func (e ListType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderByType string

const (
	OrderByTypeAsc  OrderByType = "ASC"
	OrderByTypeDesc OrderByType = "DESC"
)

var AllOrderByType = []OrderByType{
	OrderByTypeAsc,
	OrderByTypeDesc,
}

func (e OrderByType) IsValid() bool {
	switch e {
	case OrderByTypeAsc, OrderByTypeDesc:
		return true
	}
	return false
}

func (e OrderByType) String() string {
	return string(e)
}

func (e *OrderByType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderByType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderByType", str)
	}
	return nil
}

func (e OrderByType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRole string

const (
	UserRoleSuperAdmin  UserRole = "SUPER_ADMIN"
	UserRoleAdmin       UserRole = "ADMIN"
	UserRoleContributor UserRole = "CONTRIBUTOR"
	UserRoleConsumer    UserRole = "CONSUMER"
)

var AllUserRole = []UserRole{
	UserRoleSuperAdmin,
	UserRoleAdmin,
	UserRoleContributor,
	UserRoleConsumer,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleSuperAdmin, UserRoleAdmin, UserRoleContributor, UserRoleConsumer:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

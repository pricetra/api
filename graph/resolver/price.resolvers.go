package gresolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"

	"github.com/go-jet/jet/v2/postgres"
	"github.com/pricetra/api/database/jet/postgres/public/model"
	"github.com/pricetra/api/database/jet/postgres/public/table"
	"github.com/pricetra/api/graph/gmodel"
)

// CreatePrice is the resolver for the createPrice field.
func (r *mutationResolver) CreatePrice(ctx context.Context, input gmodel.CreatePrice) (*gmodel.Price, error) {
	user := r.Service.GetAuthUserFromContext(ctx)

	// Get old price
	old_price, old_price_err := r.Service.LatestPriceForProduct(ctx, input.ProductID, input.BranchID)

	price, err := r.Service.CreatePrice(ctx, user, input)
	if err != nil {
		return nil, err
	}

	price_enum := model.ProductBillingType_Price
	if old_price_err != nil {
		r.Service.CreateProductBilling(ctx, user, price_enum, *price.Product, input, nil)
	} else {
		r.Service.CreateProductBilling(ctx, user, price_enum, *price.Product, input, old_price)
	}

	// Send push notification to users
	go func() {
		ctx := context.Background()
		qb := table.ProductList.
			SELECT(table.User.AllColumns, table.AuthState.AllColumns).
			FROM(
				table.ProductList.
					INNER_JOIN(table.List,
						table.List.ID.EQ(table.ProductList.ListID).
							AND(table.List.Type.EQ(
								postgres.NewEnumValue(model.ListType_WatchList.String()),
							)),
					).
					INNER_JOIN(table.Product, table.Product.ID.EQ(table.ProductList.ProductID)).
					INNER_JOIN(table.Stock, table.Stock.ID.EQ(table.ProductList.StockID)).
					INNER_JOIN(table.User, table.User.ID.EQ(table.ProductList.UserID)).
					INNER_JOIN(table.AuthState,
						table.AuthState.UserID.EQ(table.User.ID).
							AND(table.AuthState.LoggedInAt.GT_EQ(
								postgres.NOW().SUB(postgres.INTERVAL(30, postgres.DAY)),
							)),
					),
			).
			WHERE(
				table.Product.ID.EQ(postgres.Int(input.ProductID)).
					AND(table.Stock.ID.EQ(postgres.Int(price.StockID))).
					AND(table.User.ID.NOT_EQ(postgres.Int(user.ID))).
					AND(table.AuthState.ExpoPushToken.IS_NOT_NULL()),
			).
			ORDER_BY(table.ProductList.CreatedAt.ASC())
		var users []gmodel.User
		if qb.QueryContext(ctx, r.Service.DB, &users) != nil {
			return
		}
		r.Service.SendPriceChangePushNotifications(ctx, users, price, old_price)
	}()
	return &price, nil
}

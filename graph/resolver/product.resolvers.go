package gresolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/cloudinary/cloudinary-go/v2/api/uploader"
	"github.com/pricetra/api/database/jet/postgres/public/model"
	"github.com/pricetra/api/graph/gmodel"
	"github.com/pricetra/api/services"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input gmodel.CreateProduct) (*gmodel.Product, error) {
	user := r.Service.GetAuthUserFromContext(ctx)
	source := model.ProductSourceType_Pricetra
	product, err := r.Service.CreateProduct(ctx, user, input, &source)
	if err != nil {
		return nil, err
	}

	// upload image file to CDN
	upload_params := uploader.UploadParams{
		PublicID: product.Code,
		Tags:     []string{"PRODUCT"},
	}
	if input.ImageFile != nil {
		r.Service.GraphImageUpload(ctx, *input.ImageFile, upload_params)
	} else if input.ImageBase64 != nil {
		r.Service.Base64ImageUpload(ctx, *input.ImageBase64, upload_params)
	} else if input.ImageURL != nil {
		r.Service.ImageUrlUpload(ctx, *input.ImageURL, upload_params)
	}

	// Handle billing
	r.Service.CreateProductBilling(ctx, user, model.ProductBillingType_Create, product, input, nil)
	return &product, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id int64, input gmodel.UpdateProduct) (*gmodel.Product, error) {
	user := r.Service.GetAuthUserFromContext(ctx)
	product, old_product, err := r.Service.UpdateProductById(ctx, user, id, input)
	if err != nil {
		return nil, err
	}

	// upload image file to CDN
	if input.ImageFile != nil || input.ImageBase64 != nil {
		r.Service.DeleteImageUpload(ctx, product.Code)
	}
	upload_params := uploader.UploadParams{
		PublicID: product.Code,
		Tags:     []string{"PRODUCT"},
	}
	if input.ImageFile != nil {
		r.Service.GraphImageUpload(ctx, *input.ImageFile, upload_params)
	} else if input.ImageBase64 != nil {
		r.Service.Base64ImageUpload(ctx, *input.ImageBase64, upload_params)
	}

	// Handle billing
	// TODO: fetch old product info
	r.Service.CreateProductBilling(ctx, user, model.ProductBillingType_Update, product, input, old_product)
	return &product, nil
}

// SaveProductsFromUPCItemDb is the resolver for the saveProductsFromUPCItemDb field.
func (r *mutationResolver) SaveProductsFromUPCItemDb(ctx context.Context, input gmodel.SaveExternalProductInput) (*gmodel.SearchResult, error) {
	user := r.Service.GetAuthUserFromContext(ctx)
	res, err := r.Service.UPCItemdbSaveSearchProducts(ctx, user, input)
	if err != nil {
		return nil, err
	}
	return &res, nil
}

// BarcodeScan is the resolver for the barcodeScan field.
func (r *queryResolver) BarcodeScan(ctx context.Context, barcode string, searchMode *bool) (*gmodel.Product, error) {
	user := r.Service.GetAuthUserFromContext(ctx)

	if searchMode != nil && *searchMode {
		is_exact := strings.HasPrefix(barcode, "*")
		if is_exact {
			barcode = barcode[1:]
		}
		product, err := r.Service.BarcodeSearch(ctx, barcode, is_exact)
		if err != nil {
			return nil, fmt.Errorf("no results found for this barcode")
		}
		return &product, nil
	}

	product, err := r.Service.FindProductWithCode(ctx, barcode)
	if err == nil {
		return &product, nil
	}

	result, err := r.Service.UPCItemDbLookupWithUpcCode(ctx, barcode)
	if err != nil {
		return nil, err
	}

	if len(result.Items) == 0 {
		return nil, fmt.Errorf("no results found for this barcode")
	}
	item := result.Items[0]
	source := model.ProductSourceType_Upcitemdb
	product_input := item.ToCreateProduct(ctx, r.Service, &barcode)
	product, err = r.Service.CreateProduct(ctx, user, product_input, &source)
	if err != nil {
		return nil, err
	}

	// Upload image to CDN
	if product_input.ImageURL != nil {
		_, err := r.Service.ImageUrlUpload(ctx, *product_input.ImageURL, uploader.UploadParams{
			PublicID: product.Code,
			Tags:     []string{"PRODUCT"},
		})
		if err != nil {
			log.Println("could not upload remote product image URL.", err.Error())
		}
	}

	// Handle billing
	r.Service.CreateProductBilling(ctx, user, model.ProductBillingType_Scan, product, item, nil)
	return &product, nil
}

// AllProducts is the resolver for the allProducts field.
func (r *queryResolver) AllProducts(ctx context.Context, paginator gmodel.PaginatorInput, search *gmodel.ProductSearch) (*gmodel.PaginatedProducts, error) {
	user := r.Service.GetAuthUserFromContext(ctx)
	paginated_products, err := r.Service.PaginatedProducts(ctx, paginator, search)
	if err != nil {
		return nil, err
	}

	if search != nil && search.Query != nil && len(*search.Query) > 1 {
		// search term is provided so create log in search_history table
		go func() {
			ctx := context.Background()
			r.Service.CreateSearchHistoryEntry(ctx, *search.Query, &user)
		}()
	}
	return &paginated_products, nil
}

// AllBrands is the resolver for the allBrands field.
func (r *queryResolver) AllBrands(ctx context.Context) ([]*gmodel.Brand, error) {
	brands, err := r.Service.FindAllBrands(ctx)
	if err != nil {
		return nil, err
	}
	res := make([]*gmodel.Brand, len(brands))
	for i := range res {
		res[i] = &brands[i]
	}
	return res, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id int64, viewerTrail *gmodel.ViewerTrailInput) (*gmodel.Product, error) {
	user := r.Service.GetAuthUserFromContext(ctx)
	if !r.Service.ProductExists(ctx, id) {
		return nil, fmt.Errorf("invalid product id")
	}

	product, err := r.Service.FindProductById(ctx, id)
	if err != nil {
		return nil, err
	}

	p_lists, err := r.Service.FindProductListsByUserAndProductId(ctx, user, product.ID)
	if err != nil {
		return nil, err
	}
	product.ProductList = make([]*gmodel.ProductList, len(p_lists))
	for i := range p_lists {
		product.ProductList[i] = &p_lists[i]
	}

	// log visited product
	go func() {
		ctx := context.Background()
		var platform *gmodel.AuthDeviceType
		if user.AuthDevice != nil {
			platform = user.AuthDevice
		}
		trail_input := services.ViewerTrailFull{
			UserID:   &user.ID,
			Platform: platform,
		}
		if viewerTrail != nil {
			trail_input.ViewerTrailInput = *viewerTrail
		}
		r.Service.AddProductViewer(ctx, product.ID, trail_input)
	}()

	go func ()  {
		ctx := context.Background()
		r.Service.ProcessOpenFoodFactsData(ctx, product)
	}()
	return &product, nil
}

// ExtractProductFields is the resolver for the extractProductFields field.
func (r *queryResolver) ExtractProductFields(ctx context.Context, base64Image string) (*gmodel.ProductExtractionResponse, error) {
	user := r.Service.GetAuthUserFromContext(ctx)
	fields, err := r.Service.ExtractProductTextFromBase64Image(ctx, user, base64Image)
	if err != nil {
		return nil, err
	}
	return &fields, nil
}

// MyProductViewHistory is the resolver for the myProductViewHistory field.
func (r *queryResolver) MyProductViewHistory(ctx context.Context, paginator gmodel.PaginatorInput) (*gmodel.PaginatedProducts, error) {
	user := r.Service.GetAuthUserFromContext(ctx)
	paginated_products, err := r.Service.PaginatedRecentlyViewedProducts(ctx, paginator, user)
	if err != nil {
		return nil, err
	}
	return &paginated_products, nil
}
